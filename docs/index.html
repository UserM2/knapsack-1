<h1>0-1 Knapsack Problem</h1>
<h2 style="color: #2e6c80;"><span style="color: #008080;">Abstract:</span></h2>
<p>In this work we dealt with the problem of knapsack problem 0-1 (KnapSack Problem 0-1). The backpack problem focuses on finding optimized solutions so that they do not exceed the size-capacity of each backpack. In the present work, 6 different algorithms were tested. They are:</p>
<ul>
<li><strong>Greedy approach</strong></li>
<li><strong>Brute force</strong></li>
<li><strong>Branch and bound</strong></li>
<li><strong>Dynamic programming</strong></li>
<li><strong>Dynamic OR-Tools solver</strong></li>
<li><strong>Integer OR-Tools solver</strong> &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</li>
</ul>
<h2 style="color: #2e6c80;"><span style="color: #008080;">Solutions:</span></h2>
<p>To test these solutions and record the results, random code files were created in various combinations of objects, weights and capacities. In the following tables,some of the results for these files and data regarding total weight, gain, set of selected objects, as well as execution time in graphs and tables will be grouped.</p>
<p>&nbsp;<strong>10 objects_50 capacity</strong></p>
<p><img src="https://imgbbb.com/images/2020/01/06/Screenshot_10a9feee756dce367.png" alt="Screenshot_10a9feee756dce367.png" border="0" /></p>
<p>&nbsp;<strong>5</strong><strong>0 objects_50 capacity</strong></p>
<p><img src="https://imgbbb.com/images/2020/01/06/Screenshot_230dc346f648ecb69.png" alt="Screenshot_230dc346f648ecb69.png" border="0" /></p>
<p><strong>100 objects_100 capacity</strong></p>
<p><a href="https://imgbbb.com/image/LH5lYi"><img src="https://imgbbb.com/images/2020/01/06/Screenshot_361245ad8e6e08bcb.png" alt="Screenshot_361245ad8e6e08bcb.png" border="0" /></a></p>
<p>&nbsp;50<strong>0 objects_500 capacity</strong></p>
<p><a href="https://imgbbb.com/image/LH5q57"><img src="https://imgbbb.com/images/2020/01/06/Screenshot_48bf03e148b6f6466.png" alt="Screenshot_48bf03e148b6f6466.png" border="0" /></a></p>
<h2><span style="color: #008080;">Conclusion:</span></h2>
<p><span style="color: #000000;">Finally, it seems that the nature of our problem poses the appropriateness of the methods we used. The Greedy Approach gives us the best results only for small problems. Brute Force and Branch and Bound too. In contrast, Dynamic Programming and specialized OR-TOOLS solver give the best approaches.</span></p>
